클라이언트 서버 구조
1. Request Response 구조
2. 클라이언트는 서버에 요청을 보내고, 응답을 대기
3. 서버는 요청에 대한 결과를 만들어서 응답
4. 클라이언트와 서버를 분리를 한다는 사실 자체가 중요 -> 과거엔 하나였지만, 클라이언트와 서버를 분리해서 서버엔 비즈니스 로직과 데이터를 서버에 보관하고 클라이언트는 UI와 사용성에 집중
5. 클라이언트와 서버를 분리함으로써 클라이언트와 서버가 각자 발전할 수 있게 됨

무상태 프로토콜
Stateless
1. 서버가 클라이언트의 상태를 보존 X
2. 장점 : 서버 확장성 높음(스케일 아웃)
3. 단점 : 클라이언트가 추가 데이터 전송

Stateful vs Stateless
Stateful은 서버가 요청을 받을 때 마다 클라이언트의 기존 정보를 보존함
Stateless는 서버가 요청을 받을 때 클라이언트의 기존 정보를 보존하지 않아 클라이언트가 지속적으로 추가 데이터를 전송해야함
1. 상태 유지 : 중간에 다른 점원으로 바뀌면 안됨(바뀔 시, 상태 정보를 다른 직원에게 미리 알려야함) (항상 같은 서버 유지)
2. 무상태 : 중간에 다른 점원으로 바뀌어도 된다.
    1) 갑자기 고객이 증가해도 점원을 대거 투입 할 수 있다.
    2) 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입 할 수 있다.
3. 무상태는 응답 서버를 쉽게 바꿀 수 있다. -> 무한한 서버 증설 가능

스케일 아웃 : 중계 서버 하나를 두고 클라이언트가 서버를 요청 할 경우 많은 서버 중에서 정상적인 서버를 할당(Stateless)

Stateless 실무 한계
1. 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.
2. 무상태
    예) 로그인이 필요없는 단순한 서비스 소개 화면
3. 상태유지
    예) 로그인
4. 로그인 한 사용자의 경우 로그인 했다는 상태를 서버에 유지
5. 일반적으로 브라우저 쿠키와 서버 세션 등을 사용해서 상태 유지
6. 상태 유지는 최소한만 사용
